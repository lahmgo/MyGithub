

当且仅当一个变量在is检查之后不再改变时，智能类型转换才会起作用。当你对一个带有属性的类使用智能类型转换时，正如（上面的）这个例子，属性必须是一个val（不可变类型），同时它不能有自定义的访问器。否则，它不能验证每一个属性的访问是否会返回同样的值

is检查跟Java中的instanceof很相似。但是在Java中，如果你已经检查一个变量为某个指定的类型，而且必须以指定的类型访问那个成员，那么你得在instanceof检查后面添加一个显式的类型转换。当初始变量使用超过一次，你往往会将类型转换后的结果保存到另一个变量中。在Kotlin中，编译器为你做了这份工作。如果你检查了变量的特定类型，后续你不需要执行类型转换。你可以把它当做你检查的目标类型来使用。实际上，编译器为你执行了类型转换，我们把这叫做智能类型转换(smart cast)


if (e is Num) {
    val n = e as Num        // 1 显式的Num类型转换是多余的 智能类型转换(smart cast)
    return n.value
  }

#############

https://panxl6.gitbooks.io/kotlin-in-action-in-chinese/content/2-kotlin-basics/23-zhan-xian-he-chu-li-xuan-ze-ff1a-mei-ju-548c60-when.html


你将会写一个计算像(1 + 2) + 4这样的简单数学表达式的函数。这个表达式将会包含一种类型操作：求两个数的和。其他的算术操作（减法、乘法、除法）也能够用相似的方式来实现。你也可以把它作为一个练习。
　首先，你如何编码这个表达式？你把它们存储在一个类似于树的结构中，其中的每一个节点是一个和（Sum）或者是一个数（Num）。Num一直是一个叶子节点，尽管Sum节点有两个孩子：sum操作的参数。接下来的代码片段展示了一个用来编码表达式的简单的类结构：一个叫做Expr的接口、实现这个接口的两个类Num和Sum。注意，Expr接口并没有声明任何方法。它被用做一个提供不同种类的表达式的公共类型接口记号。为了标记一个类是实现了某个接口的，你（应该）在接口名字的后面使用一个冒号（:）：

interface Expr
class Num(val value: Int) : Expr        // 1 带有一个属性、值而且实现了Expr接口的简单的值对象类
class Sum(val left: Expr, val right: Expr) : Expr    // 2 求和操作的参数可以是任意的Expr：Num对象或者其他的Sum对象
Sum存储了Expr类型的left和right的引用。在这个小案例中，它们可以是Num或者是Sum。为了存储之前提到的表达式（1 + 2） + 4，你（应该）创建一个Sum(Sum(Num(1), Num(2)), Num(4))。图2.4展示了它的树形表示。
图2.4

图2.4 Sum(Sum(Num(1), Num(2)), Num(4))表达式的一个展现
让我们看看表达式是如何求值的。计算示例中的表达式应该返回7：

>>> eval(Sum(Sum(Num(1), Num(2)), Num(4)))
7
Expr接口有两个实现，所以，为了计算一个表达式的值你必须尝试（以下）两种选项：
如果一个表达式是一个值，你必须返回对应的值
如果它是一个和，你必须由左到右计算表达式并返回它们的和
首先，我们将会着眼于用Java的常规方式来写的函数，然后我们会用Kotlin的方式来重构这份代码。在Java中，你可能已经实用一系列的if语句来检查选项，因此，让我们在Kotlin中使用同样的方法：

fun eval(e: Expr): Int {
  if (e is Num) {
    val n = e as Num        // 1 显式的Num类型转换是多余的
    return n.value
  }
  if (e is Sum) {
      return eval(e.right) + eval(e.left)    // 2 变量e是智能类型转换
  }
  throw IllegalArgumentException("Unknown expression")
}
>>> println(eval(Sum(Sum(Num(1), Num(2)), Num(4))))
7
在Kotlin中，你通过is检查一个变量是否为一个指定的类型。如果你有C#的编程经验， 你应该对这个标记很熟悉。is检查跟Java中的instanceof很相似。但是在Java中，如果你已经检查一个变量为某个指定的类型，而且必须以指定的类型访问那个成员，那么你得在instanceof检查后面添加一个显式的类型转换。当初始变量使用超过一次，你往往会将类型转换后的结果保存到另一个变量中。在Kotlin中，编译器为你做了这份工作。如果你检查了变量的特定类型，后续你不需要执行类型转换。你可以把它当做你检查的目标类型来使用。实际上，编译器为你执行了类型转换，我们把这叫做智能类型转换(smart cast)。
　在eval函数中，你检查变量e是否为Num类型之后，编译器会把这个变量当做一个Num的变量。之后你可以访问Num的value属性而不需要显式的类型转换：e.value。Sum的right和left属性也是同样的道理：你只需要在相应的上下文中写e.right和e.left。在IDE中，这些智能类型转换值会通过一个背景颜色来强调，如图2.5所示，因此很容易理解这个值是之前检查的那个。
图2.5

图2.5 IDE用一个背景颜色对智能类型转换做了高亮处理
当且仅当一个变量在is检查之后不再改变时，智能类型转换才会起作用。当你对一个带有属性的类使用智能类型转换时，正如（上面的）这个例子，属性必须是一个val（不可变类型），同时它不能有自定义的访问器。否则，它不能验证每一个属性的访问是否会返回同样的值。
　一个指定类型的显式转换通过as关键词来表达的：

val n = e as Num





